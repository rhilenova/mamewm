-*- text -*-

* When a window tries to map itself outside the physical screens,
  always map it to the screen closest to the coordinates it asked for
  instead of always mapping on the first screen in the list.

* Feature: We need to continue dragging for move and resize until
  *both* MODKEY and mouse button has been released. Will be much nicer
  with trackball.

* Move to first window (or middle of screen) on another screen
  with MODKEY + . and , instead of moving windows to new screen.
  Shifted these keys will move window to new screen?

* Handle new modes on physical outputs. What do we have to do?

* A separate workspace list for every physical output.

* Allow hexadecimal colour values on command line.

* Grab specific keys 

  Current code grabs modifier keys and any other keypress. We need to
  specifically grab the keycodes we need. xbindkeys and possibly other
  programs don't work.

  Partially done. Now grabs all our keys unshifted as well as shifted.

* Feedback window
  
  We may need to tell the user the new geometry somehow. Is this what
  I want?

  The feedback window can also show what workspace we just changed to.

  Can we cooperate with a stand-alone program? Write our status to a
  root hint or named pipe than can be picked up by another program?

* Virtual screens/workspaces

  Partially done. Still needed:

  - A window might be on one, *several* or all virtual screens. 

    We already have a way of fixing a window on all screens (Mod2-f),
    but we need a way of saying "stick on this workspace". Perhaps
    something like Mod2-a <n>, where <n> is 1--9 for virtual screens.
    Better ways? Note that this seems to be mildly incompatible with
    the EWMH _NET_WM_DESKTOP hint we're currently using: We will only
    be able to save one of the desktops used.

* Hide windows

  Instead of iconifying, hide them Ã  la 9wm. Even if we use a key to
  hide them, this probably means we have to have a menu to get them
  back. Perhaps use an external program somehow? Needs to talk to mcwm
  anyway. Unix socket?

* Menu

  We might need a menu for hidden windows (see above). Since I'm
  probably implementing menu windows anyway, perhaps I should add a
  menu with basic window functions, like 9wm and twm. This way, one
  might use the window manager without keyboard, if necessary. Not
  much work if I have to do the menu anyway... But also chords?

* Chords

  Maybe have mouse button chords to do move and resize? Configurable
  if on or off?

  Idea from Christian Neukirchen.

* Snap to border and screen edge, which favours the edge.

* Gaps on borders for docks, status windows et cetera.

  Keep space reserved for Conky, dzen2 et cetera.
  
  Also respect EWMH hints _NET_WM_TYPE_DOCK and _NET_WM_TYPE_DESKTOP.

* Flag to disable that mcwm won't allow windows to move off the
  screen?

* Use xcb-event's event handlers?

* Configurable keys.

* Configuration file.

* Handle Urgency hint

  Some windows might need attention and marks this with an urgency
  hint (for instance, urxvt can generate such a hint when receiving
  the BEL character). Do we want to handle it? How do we tell the
  user? Can this be done with some stand-alone program instead?

* Support sensible portions of ICCCM and EWMH

  EWMH hints that tells applications about active workspace and
  focused window...

  And a few others.

* Code cleaning

  - Obivous cleanup: The event switch is way too big.

  - The states are known everywhere. A tight state machine would be
    nicer.

  - Dispatch table for key bindings instead of keysym->enum->case?

  - Use bitfields instead of extra lists for virtual screens?

* Resize behaviour

  Better resize behaviour. We want not to accidentally change the
  vertical size when changing horizontal size and vice versa.
